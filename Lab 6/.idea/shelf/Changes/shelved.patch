Index: src/test/java/ru/ssau/tk/enjoyers/ooplabs/JdbcBenchmark.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package ru.ssau.tk.enjoyers.ooplabs;\r\n\r\nimport ru.ssau.tk.enjoyers.ooplabs.dao.SearchJdbcFunctionDao;\r\nimport ru.ssau.tk.enjoyers.ooplabs.dto.FunctionDto;\r\nimport ru.ssau.tk.enjoyers.ooplabs.dto.PointDto;\r\nimport ru.ssau.tk.enjoyers.ooplabs.dto.SearchCriteria;\r\nimport ru.ssau.tk.enjoyers.ooplabs.dto.UserDto;\r\nimport ru.ssau.tk.enjoyers.ooplabs.dao.JdbcFunctionDao;\r\nimport ru.ssau.tk.enjoyers.ooplabs.dao.JdbcUserDao;\r\nimport org.junit.jupiter.api.*;\r\nimport org.junit.jupiter.api.MethodOrderer.OrderAnnotation;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.FileNotFoundException;\r\nimport java.io.FileReader;\r\nimport java.io.IOException;\r\nimport java.sql.Connection;\r\nimport java.sql.PreparedStatement;\r\nimport java.sql.SQLException;\r\nimport java.util.List;\r\n\r\nimport static org.junit.jupiter.api.Assertions.*;\r\n\r\n@TestMethodOrder(OrderAnnotation.class)\r\n@DisplayName(\"JDBC Performance Tests\")\r\nclass JdbcBenchmark {\r\n    private JdbcUserDao userDao;\r\n    private JdbcFunctionDao functionDao;\r\n    private SearchJdbcFunctionDao advancedDao;\r\n    private Long testUserId;\r\n    private static final int LARGE_DATA_SIZE = 1000;\r\n\r\n    @BeforeEach\r\n    void setUp() {\r\n        StringBuilder script = new StringBuilder();\r\n        try (BufferedReader reader = new BufferedReader(new FileReader(\"C:\\\\Users\\\\User\\\\IdeaProjects\\\\ooplabs\\\\Lab 5\\\\src\\\\main\\\\resources\\\\scripts\\\\create_tables.sql\"))) {\r\n            String line;\r\n\r\n            while ((line = reader.readLine()) != null) {\r\n                script.append(line).append(\"\\n\");\r\n            }\r\n        } catch (FileNotFoundException e) {\r\n            throw new RuntimeException(e);\r\n        } catch (IOException e) {\r\n            throw new RuntimeException(e);\r\n        }\r\n\r\n        try (Connection conn = DatabaseConnection.getConnection()) {\r\n            PreparedStatement stmt = conn.prepareStatement(script.toString());{\r\n                stmt.execute();\r\n            }\r\n        } catch (SQLException e) {\r\n            throw new RuntimeException(e);\r\n        }\r\n\r\n        userDao = new JdbcUserDao();\r\n        functionDao = new JdbcFunctionDao();\r\n        advancedDao = new SearchJdbcFunctionDao(functionDao);\r\n\r\n        // Создаем тестового пользователя\r\n        UserDto user = new UserDto(\"perf_test_user_jdbc\", \"password\", Role.USER);\r\n        testUserId = userDao.save(user);\r\n        assertNotNull(testUserId, \"Failed to create test user\");\r\n    }\r\n\r\n    @AfterEach\r\n    void tearDown() {\r\n        // Очистка тестовых данных\r\n        if (testUserId != null) {\r\n            functionDao.findByUserId(testUserId).forEach(func -> functionDao.delete(func.getId()));\r\n            userDao.delete(testUserId);\r\n        }\r\n    }\r\n\r\n    @Test\r\n    @Order(1)\r\n    @DisplayName(\"Performance: Save functions with points\")\r\n    void performanceSaveFunctionsWithPoints() {\r\n        List<FunctionDto> functions = DataGenerator.generateFunctionsDto(testUserId, LARGE_DATA_SIZE);\r\n\r\n        assertAll(() -> {\r\n            long startTime = System.currentTimeMillis();\r\n\r\n            for (FunctionDto function : functions) {\r\n                Long functionId = functionDao.save(function);\r\n                assertNotNull(functionId, \"Failed to save function\");\r\n\r\n                // Генерируем точки для функции\r\n                List<PointDto> points = DataGenerator.generatePointsDto(functionId, 10, 0, 10);\r\n                functionDao.savePoints(functionId, points);\r\n            }\r\n\r\n            long endTime = System.currentTimeMillis();\r\n            long duration = endTime - startTime;\r\n\r\n            System.out.printf(\"JDBC: Saved %d functions with points in %d ms (%.2f ms per function)%n\",\r\n                    LARGE_DATA_SIZE, duration, (double) duration / LARGE_DATA_SIZE);\r\n\r\n            List<FunctionDto> savedFunctions = functionDao.findByUserId(testUserId);\r\n            assertEquals(LARGE_DATA_SIZE, savedFunctions.size());\r\n        });\r\n    }\r\n\r\n    @Test\r\n    @Order(2)\r\n    @DisplayName(\"Performance: Read functions with points\")\r\n    void performanceReadFunctionsWithPoints() {\r\n        List<FunctionDto> functions = DataGenerator.generateFunctionsDto(testUserId, LARGE_DATA_SIZE);\r\n        for (FunctionDto function : functions) {\r\n            Long functionId = functionDao.save(function);\r\n            List<PointDto> points = DataGenerator.generatePointsDto(functionId, 10, 0, 10);\r\n            functionDao.savePoints(functionId, points);\r\n        }\r\n\r\n        assertAll(() -> {\r\n            long startTime = System.currentTimeMillis();\r\n\r\n            List<FunctionDto> foundFunctions = functionDao.findByUserId(testUserId);\r\n            for (FunctionDto function : foundFunctions) {\r\n                List<PointDto> points = functionDao.findPointsByFunctionId(function.getId());\r\n\r\n                assertFalse(points.isEmpty(), \"Function should have points\");\r\n            }\r\n\r\n            long endTime = System.currentTimeMillis();\r\n            long duration = endTime - startTime;\r\n\r\n            System.out.printf(\"JDBC: Read %d functions with points in %d ms%n\",\r\n                    foundFunctions.size(), duration);\r\n        });\r\n    }\r\n\r\n    @Test\r\n    @Order(3)\r\n    @DisplayName(\"Performance: Bulk points operations\")\r\n    void performanceBulkPointsOperations() {\r\n        FunctionDto function = new FunctionDto(testUserId, \"Bulk Test Function\", \"TABULATED\",\r\n                \"Benchmark function\", 0, \"TABULATED_ARRAY\");\r\n        Long functionId = functionDao.save(function);\r\n\r\n        assertAll(() -> {\r\n            List<PointDto> points = DataGenerator.generatePointsDto(functionId, LARGE_DATA_SIZE * 10, 0, 10000);\r\n\r\n            long startTime = System.currentTimeMillis();\r\n            functionDao.savePoints(functionId, points);\r\n            long insertTime = System.currentTimeMillis() - startTime;\r\n\r\n            startTime = System.currentTimeMillis();\r\n            List<PointDto> readPoints = functionDao.findPointsByFunctionId(functionId);\r\n            long readTime = System.currentTimeMillis() - startTime;\r\n\r\n            startTime = System.currentTimeMillis();\r\n            functionDao.deleteAllPointsByFunctionId(functionId);\r\n            long deleteTime = System.currentTimeMillis() - startTime;\r\n\r\n            System.out.printf(\"JDBC Points Operations:%n\");\r\n            System.out.printf(\"  Insert %d points: %d ms%n\", LARGE_DATA_SIZE * 10, insertTime);\r\n            System.out.printf(\"  Read %d points: %d ms%n\", readPoints.size(), readTime);\r\n            System.out.printf(\"  Delete points: %d ms%n\", deleteTime);\r\n        });\r\n    }\r\n\r\n    @Test\r\n    @Order(4)\r\n    @DisplayName(\"Search with sorting\")\r\n    void testSearchWithSorting() {\r\n        List<FunctionDto> functions = DataGenerator.generateFunctionsDto(testUserId, LARGE_DATA_SIZE / 10);\r\n        for (FunctionDto function : functions) {\r\n            Long functionId = functionDao.save(function);\r\n            List<PointDto> points = DataGenerator.generatePointsDto(functionId, 10, 0, 10);\r\n            functionDao.savePoints(functionId, points);\r\n        }\r\n\r\n        List<FunctionDto> ascendingResults = advancedDao.findWithSorting(\"name\", SearchCriteria.SortDirection.ASC);\r\n        List<FunctionDto> descendingResults = advancedDao.findWithSorting(\"name\", SearchCriteria.SortDirection.DESC);\r\n\r\n        assertNotNull(ascendingResults);\r\n        assertNotNull(descendingResults);\r\n\r\n        if (ascendingResults.size() > 1 && descendingResults.size() > 1) {\r\n            // Проверяем, что сортировка работает\r\n            String firstAsc = ascendingResults.get(0).getName();\r\n            String lastAsc = ascendingResults.get(ascendingResults.size() - 1).getName();\r\n            String firstDesc = descendingResults.get(0).getName();\r\n            String lastDesc = descendingResults.get(descendingResults.size() - 1).getName();\r\n\r\n            assertTrue(firstAsc.compareTo(lastAsc) <= 0);\r\n            assertTrue(firstDesc.compareTo(lastDesc) >= 0);\r\n        }\r\n    }\r\n\r\n//    @Test\r\n//    @Order(5)\r\n//    @DisplayName(\"Performance: Concurrent access\")\r\n//    @Timeout(value = 60, unit = TimeUnit.SECONDS)\r\n//    void performanceConcurrentAccess() throws InterruptedException {\r\n//        int threadCount = 10;\r\n//        int operationsPerThread = LARGE_DATA_SIZE / threadCount;\r\n//\r\n//        Thread[] threads = new Thread[threadCount];\r\n//        final int[] successfulOperations = new int[threadCount];\r\n//\r\n//        long startTime = System.currentTimeMillis();\r\n//\r\n//        for (int i = 0; i < threadCount; i++) {\r\n//            final int threadIndex = i;\r\n//            threads[i] = new Thread(() -> {\r\n//                try {\r\n//                    for (int j = 0; j < operationsPerThread; j++) {\r\n//                        // Каждый поток работает со своей функцией\r\n//                        FunctionDto function = new FunctionDto(\r\n//                                testUserId,\r\n//                                \"Concurrent_Func_\" + threadIndex + \"_\" + j,\r\n//                                \"TABULATED\", \"Benchmark function\", 0, \"TABULATED_ARRAY\"\r\n//                        );\r\n//\r\n//                        Long functionId = functionDao.save(function);\r\n//                        if (functionId != null) {\r\n//                            successfulOperations[threadIndex]++;\r\n//                        }\r\n//                    }\r\n//                } catch (Exception e) {\r\n//                    System.err.println(\"Thread \" + threadIndex + \" failed: \" + e.getMessage());\r\n//                }\r\n//            });\r\n//            threads[i].start();\r\n//        }\r\n//\r\n//        // Ждем завершения всех потоков\r\n//        for (Thread thread : threads) {\r\n//            thread.join();\r\n//        }\r\n//\r\n//        long endTime = System.currentTimeMillis();\r\n//        long duration = endTime - startTime;\r\n//\r\n//        int totalOperations = 0;\r\n//        for (int count : successfulOperations) {\r\n//            totalOperations += count;\r\n//        }\r\n//\r\n//        System.out.printf(\"JDBC Concurrent: %d threads, %d total operations in %d ms%n\",\r\n//                threadCount, totalOperations, duration);\r\n//\r\n//        assertTrue(totalOperations >= operationsPerThread * threadCount * 0.9,\r\n//                \"At least 90% of operations should succeed\");\r\n//    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/test/java/ru/ssau/tk/enjoyers/ooplabs/JdbcBenchmark.java b/src/test/java/ru/ssau/tk/enjoyers/ooplabs/JdbcBenchmark.java
--- a/src/test/java/ru/ssau/tk/enjoyers/ooplabs/JdbcBenchmark.java	(revision f2c04381a43a93a8ea965996aab044530339896c)
+++ b/src/test/java/ru/ssau/tk/enjoyers/ooplabs/JdbcBenchmark.java	(date 1762444984363)
@@ -93,8 +93,8 @@
             long endTime = System.currentTimeMillis();
             long duration = endTime - startTime;
 
-            System.out.printf("JDBC: Saved %d functions with points in %d ms (%.2f ms per function)%n",
-                    LARGE_DATA_SIZE, duration, (double) duration / LARGE_DATA_SIZE);
+//            System.out.printf("JDBC: Saved %d functions with points in %d ms (%.2f ms per function)%n",
+//                    LARGE_DATA_SIZE, duration, (double) duration / LARGE_DATA_SIZE);
 
             List<FunctionDto> savedFunctions = functionDao.findByUserId(testUserId);
             assertEquals(LARGE_DATA_SIZE, savedFunctions.size());
@@ -125,8 +125,8 @@
             long endTime = System.currentTimeMillis();
             long duration = endTime - startTime;
 
-            System.out.printf("JDBC: Read %d functions with points in %d ms%n",
-                    foundFunctions.size(), duration);
+//            System.out.printf("JDBC: Read %d functions with points in %d ms%n",
+//                    foundFunctions.size(), duration);
         });
     }
 
